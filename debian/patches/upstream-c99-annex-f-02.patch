From 26ceb6ef386f5fb879ddccca59cc3bdc57c124f3 Mon Sep 17 00:00:00 2001
From: jzmaddock <john@johnmaddock.co.uk>
Date: Fri, 2 Dec 2016 17:54:36 +0000
Subject: [PATCH] Get cpp_dec_float, float128, and mpfr passing the C99 annex F
 tests. See https://svn.boost.org/trac/boost/ticket/12581.

---
 include/boost/multiprecision/cpp_dec_float.hpp     | 38 ++++++++-
 .../boost/multiprecision/detail/functions/pow.hpp  | 41 ++++++++--
 include/boost/multiprecision/mpfr.hpp              |  7 +-
 test/test_sf_import_c99.cpp                        | 94 ++++++++++++++--------
 4 files changed, 138 insertions(+), 42 deletions(-)

diff --git a/include/boost/multiprecision/cpp_dec_float.hpp b/include/boost/multiprecision/cpp_dec_float.hpp
index bcda7cf..17bb276 100644
--- a/include/boost/multiprecision/cpp_dec_float.hpp
+++ b/include/boost/multiprecision/cpp_dec_float.hpp
@@ -1254,9 +1254,15 @@ cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, Expone
 {
    // Compute the square root of *this.
 
+   if((isinf)() && !isneg())
+   {
+      return *this;
+   }
+
    if(isneg() || (!(isfinite)()))
    {
       *this = nan();
+      errno = EDOM;
       return *this;
    }
 
@@ -2312,6 +2318,11 @@ void cpp_dec_float<Digits10, ExponentType, Allocator>::from_unsigned_long_long(c
    fpclass = cpp_dec_float_finite;
    prec_elem = cpp_dec_float_elem_number;
 
+   if(u == 0)
+   {
+      return;
+   }
+
    std::size_t i =static_cast<std::size_t>(0u);
 
    boost::ulong_long_type uu = u;
@@ -2822,6 +2833,8 @@ inline void eval_floor(cpp_dec_float<Digits10, ExponentType, Allocator>& result,
    result = x;
    if(!(x.isfinite)() || x.isint())
    {
+      if((x.isnan)())
+         errno = EDOM;
       return;
    }
 
@@ -2836,6 +2849,8 @@ inline void eval_ceil(cpp_dec_float<Digits10, ExponentType, Allocator>& result,
    result = x;
    if(!(x.isfinite)() || x.isint())
    {
+      if((x.isnan)())
+         errno = EDOM;
       return;
    }
 
@@ -2850,6 +2865,8 @@ inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result,
    if(x.isint() || !(x.isfinite)())
    {
       result = x;
+      if((x.isnan)())
+         errno = EDOM;
       return;
    }
    result = x.extract_integer_part();
@@ -2858,6 +2875,20 @@ inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result,
 template <unsigned Digits10, class ExponentType, class Allocator>
 inline ExponentType eval_ilogb(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
 {
+   if(val.iszero())
+#ifdef FP_ILOGB0
+      return  FP_ILOGB0;
+#else
+      return INT_MIN;
+#endif
+   if((val.isinf)())
+      return INT_MAX;
+   if((val.isnan)())
+#ifdef FP_ILOGBNAN
+      return FP_ILOGBNAN;
+#else
+      return INT_MAX;
+#endif
    // Set result, to the exponent of val:
    return val.order();
 }
@@ -2892,15 +2923,16 @@ template <unsigned Digits10, class ExponentType, class Allocator>
 inline void eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)
 {
    result = x;
-   if(result.isneg())
-      result.negate();
 
-   if(result.iszero())
+   if(result.iszero() || (result.isinf)() || (result.isnan)())
    {
       *e = 0;
       return;
    }
 
+   if(result.isneg())
+      result.negate();
+
    ExponentType t = result.order();
    BOOST_MP_USING_ABS
    if(abs(t) < ((std::numeric_limits<ExponentType>::max)() / 1000))
diff --git a/include/boost/multiprecision/detail/functions/pow.hpp b/include/boost/multiprecision/detail/functions/pow.hpp
index 260f7c8..514a9aa 100644
--- a/include/boost/multiprecision/detail/functions/pow.hpp
+++ b/include/boost/multiprecision/detail/functions/pow.hpp
@@ -213,7 +213,6 @@ void eval_exp(T& result, const T& x)
    }
    else if(type == (int)FP_INFINITE)
    {
-      result = x;
       if(isneg)
          result = ui_type(0u);
       else 
@@ -278,6 +277,17 @@ void eval_exp(T& result, const T& x)
       detail::pow_imp(result, get_constant_e<T>(), ll, mpl::true_());
       return;
    }
+   else if(exp_series.compare(x) == 0)
+   {
+      // We have a value that has no fractional part, but is too large to fit 
+      // in a long long, in this situation the code below will fail, so
+      // we're just going to assume that this will overflow:
+      if(isneg)
+         result = ui_type(0);
+      else
+         result = std::numeric_limits<number<T> >::has_infinity ? std::numeric_limits<number<T> >::infinity().backend() : (std::numeric_limits<number<T> >::max)().backend();
+      return;
+   }
 
    // The algorithm for exp has been taken from MPFUN.
    // exp(t) = [ (1 + r + r^2/2! + r^3/3! + r^4/4! ...)^p2 ] * 2^n
@@ -482,12 +492,29 @@ inline void eval_pow(T& result, const T& x, const T& a)
          {
             boost::intmax_t i;
             eval_convert_to(&i, a);
-            if((a.compare(i) == 0) && (i & 1) && eval_signbit(a))
+            if(a.compare(i) == 0)
             {
-               result = std::numeric_limits<number<T> >::infinity().backend();
-               if(eval_signbit(x))
-                  result.negate();
-               errno = ERANGE;
+               if(eval_signbit(a))
+               {
+                  if(i & 1)
+                  {
+                     result = std::numeric_limits<number<T> >::infinity().backend();
+                     if(eval_signbit(x))
+                        result.negate();
+                     errno = ERANGE;
+                  }
+                  else
+                  {
+                     result = std::numeric_limits<number<T> >::infinity().backend();
+                     errno = ERANGE;
+                  }
+               }
+               else if(i & 1)
+               {
+                  result = x;
+               }
+               else
+                  result = si_type(0);
                return;
             }
          }
@@ -792,6 +819,8 @@ namespace detail{
          T e_px, e_mx;
          eval_exp(e_px, x);
          eval_divide(e_mx, ui_type(1), e_px);
+         if(eval_signbit(e_mx) != eval_signbit(e_px))
+            e_mx.negate();  // Handles lack of signed zero in some types
 
          if(p_sinh) 
          { 
diff --git a/include/boost/multiprecision/mpfr.hpp b/include/boost/multiprecision/mpfr.hpp
index c78771c..f6f9a62 100644
--- a/include/boost/multiprecision/mpfr.hpp
+++ b/include/boost/multiprecision/mpfr.hpp
@@ -1322,7 +1322,12 @@ inline int eval_fpclassify(const mpfr_float_backend<Digits10, AllocateType>& val
 template <unsigned Digits10, mpfr_allocation_type AllocateType>
 inline void eval_pow(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)
 {
-   mpfr_pow(result.data(), b.data(), e.data(), GMP_RNDN);
+   if(mpfr_zero_p(b.data()) && mpfr_integer_p(e.data()) && (mpfr_signbit(e.data()) == 0) && mpfr_fits_ulong_p(e.data(), GMP_RNDN) && (mpfr_get_ui(e.data(), GMP_RNDN) & 1))
+   {
+      mpfr_set(result.data(), b.data(), GMP_RNDN);
+   }
+   else
+      mpfr_pow(result.data(), b.data(), e.data(), GMP_RNDN);
 }
 
 #ifdef BOOST_MSVC
diff --git a/test/test_sf_import_c99.cpp b/test/test_sf_import_c99.cpp
index 42133e7..8ddb901 100644
--- a/test/test_sf_import_c99.cpp
+++ b/test/test_sf_import_c99.cpp
@@ -586,6 +586,25 @@ void test_poison()
 }
 
 template <class T>
+bool type_sets_errno(const T&)
+{
+   return true;
+}
+#ifdef TEST_MPFR_50
+template<unsigned Digits10, boost::multiprecision::mpfr_allocation_type AllocateType, boost::multiprecision::expression_template_option ExpressionTemplates>
+bool type_sets_errno(const boost::multiprecision::number<boost::multiprecision::mpfr_float_backend<Digits10, AllocateType>, ExpressionTemplates> &)
+{
+   return false;
+}
+#endif
+#ifdef TEST_FLOAT128
+bool type_sets_errno(const boost::multiprecision::float128 &)
+{
+   return false;
+}
+#endif
+
+template <class T>
 typename boost::enable_if_c<std::numeric_limits<T>::is_specialized>::type check_invalid(const T& val)
 {
    if(std::numeric_limits<T>::has_quiet_NaN)
@@ -596,7 +615,8 @@ typename boost::enable_if_c<std::numeric_limits<T>::is_specialized>::type check_
    {
       BOOST_CHECK_EQUAL(val, 0);
    }
-   BOOST_CHECK_EQUAL(errno, EDOM);
+   if(type_sets_errno(val))
+      BOOST_CHECK_EQUAL(errno, EDOM);
    errno = 0;
 }
 
@@ -606,9 +626,11 @@ typename boost::disable_if_c<std::numeric_limits<T>::is_specialized>::type check
    check_invalid(static_cast<typename T::result_type>(val));
 }
 
-void check_erange()
+template <class T>
+void check_erange(const T& val)
 {
-   BOOST_CHECK_EQUAL(errno, ERANGE);
+   if(type_sets_errno(val))
+      BOOST_CHECK_EQUAL(errno, ERANGE);
    errno = 0;
 }
 
@@ -620,6 +642,7 @@ void test_c99_appendix_F()
    // special cases, infinities and NaN's.
    //
    errno = 0;
+   T tol = std::numeric_limits<T>::epsilon();
    // F.9.1.1:
    T arg = 1;
    T val = acos(arg);
@@ -783,9 +806,12 @@ void test_c99_appendix_F()
       BOOST_CHECK_EQUAL(val, 0);
       BOOST_CHECK(signbit(val) == 0);
       arg = -arg;
-      val = atan2(arg, arg2);
-      BOOST_CHECK_EQUAL(val, 0);
-      BOOST_CHECK(signbit(val));
+      if(signbit(-T(0)))
+      {
+         val = atan2(arg, arg2);
+         BOOST_CHECK_EQUAL(val, 0);
+         BOOST_CHECK(signbit(val));
+      }
       arg = std::numeric_limits<T>::infinity();
       arg2 = 2;
       val = atan2(arg, arg2);
@@ -803,17 +829,17 @@ void test_c99_appendix_F()
       arg = std::numeric_limits<T>::infinity();
       arg2 = -std::numeric_limits<T>::infinity();
       val = atan2(arg, arg2);
-      BOOST_CHECK_EQUAL(val, boost::math::constants::three_quarters_pi<T>());
+      BOOST_CHECK_CLOSE_FRACTION(val, boost::math::constants::three_quarters_pi<T>(), tol);
       arg = -arg;
       val = atan2(arg, arg2);
-      BOOST_CHECK_EQUAL(val, -boost::math::constants::three_quarters_pi<T>());
+      BOOST_CHECK_CLOSE_FRACTION(val, -boost::math::constants::three_quarters_pi<T>(), tol);
       arg = std::numeric_limits<T>::infinity();
       arg2 = std::numeric_limits<T>::infinity();
       val = atan2(arg, arg2);
-      BOOST_CHECK_EQUAL(val, ldexp(boost::math::constants::pi<T>(), -2));
+      BOOST_CHECK_CLOSE_FRACTION(val, ldexp(boost::math::constants::pi<T>(), -2), tol);
       arg = -arg;
       val = atan2(arg, arg2);
-      BOOST_CHECK_EQUAL(val, -ldexp(boost::math::constants::pi<T>(), -2));
+      BOOST_CHECK_CLOSE_FRACTION(val, -ldexp(boost::math::constants::pi<T>(), -2), tol);
       if(std::numeric_limits<T>::has_quiet_NaN)
       {
          arg = std::numeric_limits<T>::quiet_NaN();
@@ -972,12 +998,12 @@ void test_c99_appendix_F()
       val = atanh(arg);
       BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
       BOOST_CHECK(signbit(val) == 0);
-      check_erange();
+      check_erange(val);
       arg = -arg;
       val = atanh(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
       BOOST_CHECK(signbit(val));
-      check_erange();
+      check_erange(val);
 
       arg = std::numeric_limits<T>::infinity();
       check_invalid(atanh(arg));
@@ -1265,13 +1291,13 @@ void test_c99_appendix_F()
       arg = 0;
       val = log(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = log(arg);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = -1;
       check_invalid(log(arg));
@@ -1298,13 +1324,13 @@ void test_c99_appendix_F()
       arg = 0;
       val = log10(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = log10(arg);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = -1;
       check_invalid(log10(arg));
@@ -1338,7 +1364,7 @@ void test_c99_appendix_F()
       arg = -1;
       val = log1p(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -2;
       check_invalid(log1p(arg));
       arg = -std::numeric_limits<T>::infinity();
@@ -1364,13 +1390,13 @@ void test_c99_appendix_F()
       arg = 0;
       val = log2(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = log2(arg);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = -1;
       check_invalid(log2(arg));
@@ -1393,13 +1419,13 @@ void test_c99_appendix_F()
       arg = 0;
       val = logb(arg);
       BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = logb(arg);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = std::numeric_limits<T>::infinity();
       val = logb(arg);
@@ -1516,25 +1542,25 @@ void test_c99_appendix_F()
       arg2 = -3;
       val = pow(arg, arg2);
       BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = pow(arg, arg2);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = 0;
       arg2 = -2;
       val = pow(arg, arg2);
       BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = pow(arg, arg2);
          BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = 0;
       arg2 = 3;
@@ -1558,7 +1584,7 @@ void test_c99_appendix_F()
       {
          val = pow(arg, arg2);
          BOOST_CHECK_EQUAL(val, 0);
-         BOOST_CHECK(signbit(val));
+         BOOST_CHECK(signbit(val) == 0);
       }
       arg = -1;
       arg2 = std::numeric_limits<T>::infinity();
@@ -1633,7 +1659,8 @@ void test_c99_appendix_F()
       arg2 = -3;
       val = pow(arg, arg2);
       BOOST_CHECK_EQUAL(val, 0);
-      BOOST_CHECK(signbit(val));
+      if(signbit(-T(0)))
+         BOOST_CHECK(signbit(val));
       arg2 = -2;
       val = pow(arg, arg2);
       BOOST_CHECK_EQUAL(val, 0);
@@ -1753,15 +1780,15 @@ void test_c99_appendix_F()
    arg = 0;
    val = lgamma(arg);
    BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-   check_erange();
+   check_erange(val);
    arg = -1;
    val = lgamma(arg);
    BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-   check_erange();
+   check_erange(val);
    arg = -2;
    val = lgamma(arg);
    BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-   check_erange();
+   check_erange(val);
    arg = -std::numeric_limits<T>::infinity();
    val = lgamma(arg);
    BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
@@ -1779,13 +1806,13 @@ void test_c99_appendix_F()
       arg = 0;
       val = tgamma(arg);
       BOOST_CHECK_EQUAL(val, std::numeric_limits<T>::infinity());
-      check_erange();
+      check_erange(val);
       arg = -arg;
       if(signbit(arg))
       {
          val = tgamma(arg);
          BOOST_CHECK_EQUAL(val, -std::numeric_limits<T>::infinity());
-         check_erange();
+         check_erange(val);
       }
       arg = -1;
       check_invalid(tgamma(arg));
@@ -2002,6 +2029,7 @@ int main()
 #ifdef TEST_MPFR_50
    test<boost::multiprecision::mpfr_float_50>();
    test<boost::multiprecision::mpfr_float_100>();
+   test_c99_appendix_F<boost::multiprecision::mpfr_float_50>();
 #endif
 #ifdef TEST_MPFI_50
    test<boost::multiprecision::mpfi_float_50>();
@@ -2010,6 +2038,7 @@ int main()
 #ifdef TEST_CPP_DEC_FLOAT
    test<boost::multiprecision::cpp_dec_float_50>();
    test<boost::multiprecision::cpp_dec_float_100>();
+   test_c99_appendix_F<boost::multiprecision::cpp_dec_float_50>();
 #ifndef SLOW_COMPLER
    // Some "peculiar" digit counts which stress our code:
    test<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<65> > >();
@@ -2030,6 +2059,7 @@ int main()
 #endif
 #ifdef TEST_FLOAT128
    test<boost::multiprecision::float128>();
+   test_c99_appendix_F<boost::multiprecision::float128>();
 #endif
 
    return boost::report_errors();
