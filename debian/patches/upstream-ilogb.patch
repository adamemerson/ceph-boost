From c0df5b6747d09268256b59501c3cab746112268e Mon Sep 17 00:00:00 2001
From: jzmaddock <john@johnmaddock.co.uk>
Date: Sat, 3 Dec 2016 08:50:38 +0000
Subject: [PATCH] Change ilogb to consistently return the minimum value of the
 exponent type (which may be either narrower or wider than the int return type
 specified in C99). Change transcendental code which uses ilogb for loop
 termination, to check for a minimal value return to correctly handle the case
 that the value has gone to zero. See
 https://svn.boost.org/trac/boost/ticket/12625

---
 include/boost/multiprecision/cpp_dec_float.hpp         | 6 +-----
 include/boost/multiprecision/detail/default_ops.hpp    | 4 ----
 include/boost/multiprecision/detail/functions/trig.hpp | 8 ++------
 test/test_sf_import_c99.cpp                            | 7 +------
 4 files changed, 4 insertions(+), 21 deletions(-)

diff --git a/include/boost/multiprecision/cpp_dec_float.hpp b/include/boost/multiprecision/cpp_dec_float.hpp
index 17bb276..f9e6a22 100644
--- a/include/boost/multiprecision/cpp_dec_float.hpp
+++ b/include/boost/multiprecision/cpp_dec_float.hpp
@@ -2876,11 +2876,7 @@ template <unsigned Digits10, class ExponentType, class Allocator>
 inline ExponentType eval_ilogb(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
 {
    if(val.iszero())
-#ifdef FP_ILOGB0
-      return  FP_ILOGB0;
-#else
-      return INT_MIN;
-#endif
+      return (std::numeric_limits<ExponentType>::min)();
    if((val.isinf)())
       return INT_MAX;
    if((val.isnan)())
diff --git a/include/boost/multiprecision/detail/default_ops.hpp b/include/boost/multiprecision/detail/default_ops.hpp
index feab0aa..334db06 100644
--- a/include/boost/multiprecision/detail/default_ops.hpp
+++ b/include/boost/multiprecision/detail/default_ops.hpp
@@ -1486,11 +1486,7 @@ inline typename B::exponent_type eval_ilogb(const B& val)
    case FP_INFINITE:
       return (std::numeric_limits<typename B::exponent_type>::max)();
    case FP_ZERO:
-#ifdef FP_ILOGB0
-      return FP_ILOGB0;
-#else
       return (std::numeric_limits<typename B::exponent_type>::min)();
-#endif
    }
    B result;
    eval_frexp(result, val, &e);
diff --git a/include/boost/multiprecision/detail/functions/trig.hpp b/include/boost/multiprecision/detail/functions/trig.hpp
index 75835df..319b708 100644
--- a/include/boost/multiprecision/detail/functions/trig.hpp
+++ b/include/boost/multiprecision/detail/functions/trig.hpp
@@ -527,10 +527,8 @@ void eval_asin(T& result, const T& x)
       eval_divide(sine, cosine);
       eval_subtract(result, sine);
       current_precision = eval_ilogb(sine);
-#ifdef FP_ILOGB0
-      if(current_precision == FP_ILOGB0)
+      if(current_precision <= (std::numeric_limits<typename T::exponent_type>::min)() + 1)
          break;
-#endif
    }
    if(b_neg)
       result.negate();
@@ -681,10 +679,8 @@ void eval_atan(T& result, const T& x)
       eval_multiply(s, t, c);
       eval_add(result, s);
       current_precision = eval_ilogb(s);
-#ifdef FP_ILOGB0
-      if(current_precision == FP_ILOGB0)
+      if(current_precision <= (std::numeric_limits<typename T::exponent_type>::min)() + 1)
          break;
-#endif
    }
    if(b_neg)
       result.negate();
diff --git a/test/test_sf_import_c99.cpp b/test/test_sf_import_c99.cpp
index 8ddb901..17dd3d9 100644
--- a/test/test_sf_import_c99.cpp
+++ b/test/test_sf_import_c99.cpp
@@ -1250,12 +1250,7 @@ void test_c99_appendix_F()
       BOOST_CHECK(isnan(val));
    }
    // F.9.3.5:
-   int fp_ilogb0 =
-#ifdef FP_ILOGB0
-      FP_ILOGB0;
-#else
-      INT_MIN;
-#endif
+   int fp_ilogb0 = (std::numeric_limits<typename T::backend_type::exponent_type>::min)();
    int fp_ilogbnan = 
 #ifdef FP_ILOGBNAN
       FP_ILOGBNAN;
